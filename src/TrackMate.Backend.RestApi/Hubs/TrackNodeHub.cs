using Microsoft.AspNetCore.SignalR;
using System.Collections.Concurrent;
using Trackmate.Backend;
using Trackmate.Backend.Models;

namespace TrackMate.Backend.RestApi.Hubs;

public class TrackNodeHub(ILogger<TrackNodeHub> logger, TrackNodeService trackNodeService) : Hub
{
    private static readonly ConcurrentDictionary<string, List<ISingleClientProxy>> _trackSubscribers = new();

    private static readonly Dictionary<Guid, Stream> _trackNodeUploadDictionary = new();

    private static readonly Dictionary<string, Stream> _trackPictureUploadDictionary = new();

    /// <summary>
    ///     Creates a new <see cref="TrackNodeModel"/> to be used to create tracks.
    ///     This method does not complete the node, as the picture is uploaded in chunks with the method <see cref="UploadPictureChunkForTrackNode"/>.
    /// </summary>
    public async Task<TrackNodeModel> CreateTrackNode(CreateTrackNodeModel model, CancellationToken cancellationToken = default)
    {
        TrackNodeModel createTrackNodeModel = await trackNodeService.CreateTrackNodeAsync(model, cancellationToken);
        _trackNodeUploadDictionary[createTrackNodeModel.Id] = new MemoryStream();

        return createTrackNodeModel;
    }

    /// <summary>
    ///    Uploads a chunk of a picture for a track node.
    /// </summary>
    /// <param name="trackNodeId">Id of the <see cref="TrackNodeModel"/> generated by <see cref="CreateTrackNode"/>.</param>
    /// <param name="mimeType">Mime/Type of the uploaded image.</param>
    /// <param name="chunk">Byte chunk of the image uploaded.</param>
    /// <param name="isLastChunk">Flag if the upload is completed.</param>
    public async Task UploadPictureChunkForTrackNode(Guid trackNodeId, string mimeType, byte[] chunk, bool isLastChunk, CancellationToken cancellationToken = default)
    {
        logger.LogInformation("Uploaded chunk({byteSize}) for new track node {trackNodeId}.", chunk.Length, trackNodeId);
        await _trackNodeUploadDictionary[trackNodeId].WriteAsync(chunk);

        if (isLastChunk)
        {
            logger.LogInformation("Uploaded last chunk for track node {trackNodeId}, MimeType: {mimeType}.", trackNodeId, mimeType);
            await Clients.Caller.SendAsync("Uploaded ", trackNodeId);

            Stream stream = _trackNodeUploadDictionary[trackNodeId];
            _trackNodeUploadDictionary.Remove(trackNodeId);
            stream.Seek(0, SeekOrigin.Begin);

            await trackNodeService.UploadTrackNodePictureAsync(new UploadPictureModel(trackNodeId, mimeType, stream), cancellationToken);
            logger.LogInformation("Uploaded picture for track node {trackNodeId}.", trackNodeId);
        }
    }

    /// <summary>
    ///     Create a new track to a defined goal <see cref="TrackNodeModel"/>. <br />
    ///     A track id is created and returned to the caller, which can be used for others to join the track.
    /// </summary>
    /// <param name="startTrackModel">Information to create a track.</param>
    public async Task StartTrack(StartTrackModel startTrackModel)
    {
        string trackId = Guid.NewGuid().ToString("N").Substring(0, 8);

        _trackSubscribers.AddOrUpdate(
            trackId, 
            new List<ISingleClientProxy> { Clients.Caller },
            (_, list) => 
            {
                list.Add(Clients.Caller);
                return list;
            });

        await Clients.Caller.SendAsync("TrackStarted", trackId);
    }

    /// <summary>
    ///     Joins a ongoing track, subscribing to the updates of the track progress.
    /// </summary>
    /// <param name="trackId">Id of the track to join.</param>
    public async Task JoinTrack(string trackId)
    {
        _trackSubscribers[trackId].Add(Clients.Caller);
        await SendToTrackAsync(trackId, "UserJoined");
    }

    /// <summary>
    ///     Completes a track, notifying all subscribers that the track is completed.
    /// </summary>
    /// <param name="trackId">Ud of the track to complete.</param>
    public async Task CompleteTrack(string trackId)
    {
        await SendToTrackAsync(trackId, "TrackCompleted");
        _trackSubscribers.TryRemove(trackId, out _);
    }

    /// <summary>
    ///    Uploads a picture for an ongoing track.
    /// </summary>
    /// <param name="trackId"></param>
    /// <param name="mimeType"></param>
    /// <param name="chunk"></param>
    /// <param name="isLastChunk"></param>
    /// <returns></returns>
    public async Task UploadTrackPositionPicture(string trackId, string mimeType, byte[] chunk, bool isLastChunk)
    {
        logger.LogInformation("Uploaded chunk({byteSize}) for track position {trackId}.", chunk.Length, trackId);

        await _trackPictureUploadDictionary[trackId].WriteAsync(chunk);

        if (isLastChunk)
        {
            logger.LogInformation("Uploaded last chunk for track {trackId} to find position, MimeType: {mimeType}.", trackId, mimeType);
            await Clients.Caller.SendAsync("TrackPositionPictureUploaded", trackId);

            Stream stream = _trackPictureUploadDictionary[trackId];
            _trackPictureUploadDictionary.Remove(trackId);
            stream.Seek(0, SeekOrigin.Begin);

            // await trackNodeService.UploadPicture(new UploadPictureModel(trackNodeId, mimeType, stream));
        }
    }

    private Task SendToTrackAsync(string trackId, string methodName, object? arg1 = null)
        => Task.WhenAll(_trackSubscribers[trackId].Select(client => client.SendAsync(methodName, arg1)));
}
