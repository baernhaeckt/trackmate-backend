using Microsoft.AspNetCore.SignalR;
using System.Collections.Concurrent;
using Trackmate.Backend;
using Trackmate.Backend.Models;
using Trackmate.Backend.TrackNodes;
using Trackmate.Backend.Tracks;

namespace TrackMate.Backend.RestApi.Hubs;

public class TrackNodeHub(ILogger<TrackNodeHub> logger, TrackNodeService trackNodeService, TrackService trackService) : Hub
{
    private static readonly ConcurrentDictionary<string, List<ISingleClientProxy>> _trackSubscribers = new();

    /// <summary>
    ///     Creates a new <see cref="TrackNodeModel"/> to be used to create tracks.
    ///     This method does not complete the node, as the picture is uploaded in chunks with the method <see cref="UploadPictureChunkForTrackNode"/>.
    /// </summary>
    public async Task<TrackNodeModel> CreateTrackNode(CreateTrackNodeModel model)
    {
        return await trackNodeService.CreateTrackNodeAsync(model, default);
    }

    /// <summary>
    ///    Uploads a chunk of a picture for a track node.
    /// </summary>
    /// <param name="trackNodeId">Id of the <see cref="TrackNodeModel"/> generated by <see cref="CreateTrackNode"/>.</param>
    /// <param name="mimeType">Mime/Type of the uploaded image.</param>
    /// <param name="chunk">Byte chunk of the image uploaded.</param>
    /// <param name="isLastChunk">Flag if the upload is completed.</param>
    public async Task UploadPictureChunkForTrackNode(UploadPictureModel uploadPictureModel)
    {
        await trackNodeService.UploadTrackNodePictureAsync(uploadPictureModel, default);
    }

    /// <summary>
    ///     Create a new track to a defined goal <see cref="TrackNodeModel"/>. <br />
    ///     A track id is created and returned to the caller, which can be used for others to join the track.
    /// </summary>
    /// <param name="startTrackModel">Information to create a track.</param>
    public async Task<string> StartTrack(StartTrackModel startTrackModel)
    {
        string trackId = Guid.NewGuid().ToString("N").Substring(0, 8);

        _trackSubscribers.AddOrUpdate(
            trackId, 
            new List<ISingleClientProxy> { Clients.Caller },
            (_, list) => 
            {
                list.Add(Clients.Caller);
                return list;
            });

        return trackId;
    }

    /// <summary>
    ///     Joins a ongoing track, subscribing to the updates of the track progress.
    /// </summary>
    /// <param name="trackId">Id of the track to join.</param>
    public async Task JoinTrack(string trackId)
    {
        _trackSubscribers[trackId].Add(Clients.Caller);
        await SendToTrackAsync(trackId, "UserJoined");
    }

    /// <summary>
    ///     Completes a track, notifying all subscribers that the track is completed.
    /// </summary>
    /// <param name="trackId">Id of the track to complete.</param>
    public async Task CompleteTrack(string trackId)
    {
        await SendToTrackAsync(trackId, "TrackCompleted");
        _trackSubscribers.TryRemove(trackId, out _);
    }

    public async Task UploadTrackPositionPicture(UploadTrackPositionPicture uploadTrackPositionPicture)
    {
        logger.LogInformation("Uploaded picture for track position {trackId}.", uploadTrackPositionPicture.TrackId);

        TrackUpdateResult result = await trackService.UpdateTrackAsync(uploadTrackPositionPicture, default);
    }

    private Task SendToTrackAsync(string trackId, string methodName, object? arg1 = null)
        => Task.WhenAll(_trackSubscribers[trackId].Select(client => client.SendAsync(methodName, arg1)));
}
